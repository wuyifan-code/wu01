
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç¬¨ç‹—å°æŸ´ äº”å­æ£‹ v10.3 â€” å€’è®¡æ—¶å±…ä¸­å¤§å­—ç‰ˆ</title>
  <style>
    :root{
      --bg:#f6f3ee; --glass:rgba(255,255,255,0.62); --wood:#caa46b; --dark-wood:#8b6a3f;
      --text:#2e2e2e; --muted:#7b6a5c; --accent:#c08a3f; --radius:18px; --shadow:0 12px 40px rgba(0,0,0,0.12);
      --online:#2ecc71; --offline:#e74c3c;
    }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;font-family:"SF Pro Display","PingFang SC",system-ui,Arial;background:radial-gradient(circle at 10% 10%, #fffaf4,#f0e7db);color:var(--text);display:flex;flex-direction:column;align-items:center}
    .container{width:100%;max-width:1200px;padding:18px;display:flex;flex-direction:column;gap:12px;align-items:center}
    .topbar{width:100%;display:flex;align-items:center;justify-content:space-between;padding:12px 18px;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,0.9),rgba(255,255,255,0.82));box-shadow:var(--shadow);border:1px solid rgba(0,0,0,0.04)}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:48px;height:48px;border-radius:12px;background:linear-gradient(180deg,var(--accent),#b46d2f);display:flex;align-items:center;justify-content:center;color:white;font-weight:800}
    .nav{display:flex;gap:8px;align-items:center}
    .nav .pill{padding:8px 12px;border-radius:10px;border:0;cursor:pointer;font-weight:700;background:white;border:1px solid rgba(0,0,0,0.06)}
    .status-dot{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:8px}
    .scenes{width:100%;display:flex;justify-content:center}
    .scene{width:100%;display:none}
    .scene.visible{display:block}
    .card{backdrop-filter:blur(14px);background:var(--glass);border-radius:16px;padding:18px;border:1px solid rgba(255,255,255,0.5);box-shadow:0 10px 30px rgba(0,0,0,0.06)}
    .pill{padding:9px 14px;border-radius:999px;border:0;cursor:pointer;font-weight:800}
    .pill.primary{background:linear-gradient(180deg,var(--accent),var(--dark-wood));color:white}
    .pill.ghost{background:white;border:1px solid rgba(0,0,0,0.06)}
    .board-wrap{position:relative;width:640px;height:640px}
    .board{width:100%;height:100%;border-radius:12px;background:linear-gradient(180deg,#ead5b5,#d4b88c);border:6px solid rgba(202,164,107,0.9);display:grid;grid-template-columns:repeat(15,1fr);grid-template-rows:repeat(15,1fr);box-shadow:0 18px 70px rgba(0,0,0,0.12);position:relative;overflow:hidden}
    .cell{position:relative;cursor:pointer;user-select:none}
    .cell::before{content:'';position:absolute;left:0;right:0;top:50%;height:1px;background:rgba(0,0,0,0.18);transform:translateY(-50%)}
    .cell::after{content:'';position:absolute;top:0;bottom:0;left:50%;width:1px;background:rgba(0,0,0,0.18);transform:translateX(-50%)}
    .piece{width:82%;height:82%;border-radius:50%;margin:auto;transform:scale(0.01);transition:transform 220ms cubic-bezier(.2,.9,.2,1),box-shadow 200ms;box-shadow:0 6px 20px rgba(0,0,0,0.28),inset 0 4px 10px rgba(255,255,255,0.06)}
    .piece.drop{transform:scale(1)}
    .black{background:radial-gradient(circle at 30% 25%,#3f3f3f,#000)}
    .white{background:radial-gradient(circle at 30% 25%,#fff,#eee);border:1px solid rgba(0,0,0,0.06)}
    .winning-piece{box-shadow:0 0 40px 10px rgba(192,138,63,0.14),0 8px 40px rgba(0,0,0,0.26);animation:winPulse 1.6s infinite}
    @keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.04)}100%{transform:scale(1)}}
    .chat-log{height:46vh;overflow:auto;padding:10px;background:linear-gradient(180deg,rgba(255,255,255,0.9),rgba(255,255,255,0.88));border-radius:10px;border:1px solid rgba(0,0,0,0.04)}
    .chat-row{margin-bottom:8px}
    .chat-meta{color:var(--muted);font-size:0.82rem}
    #victoryModal{display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1200}
    #victoryModal .modal{background:#fffaf5;padding:18px;border-radius:12px;box-shadow:0 30px 80px rgba(0,0,0,0.16);text-align:center}
    /* knowledge card modal */
    #knowledgeModal{display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%) scale(.98);z-index:1250;transition:all 220ms ease}
    #knowledgeModal.show{display:block;transform:translate(-50%,-50%) scale(1)}
    .kcard{width:560px;max-width:92vw;background:linear-gradient(180deg,rgba(255,255,255,0.98),#fff);border-radius:14px;padding:18px;box-shadow:0 30px 80px rgba(0,0,0,0.18);display:flex;gap:12px;align-items:flex-start}
    .k-avatar{width:120px;height:120px;border-radius:12px;flex:0 0 120px;background:linear-gradient(180deg,#fff,#f3f3f3);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:20px}
    .k-body{flex:1}
    .k-name{font-weight:900;font-size:1.1rem}
    .k-quote{margin-top:8px;font-style:italic;color:#555}
    .k-meta{margin-top:10px;color:var(--muted);font-size:0.9rem}
    .confetti-canvas{position:fixed;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:1220}
    /* small piece badge next to player name */
    .player-row{display:flex;align-items:center;gap:8px}
    .piece-badge{width:18px;height:18px;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,0.12);flex:0 0 18px}
    .badge-black{background:#000}
    .badge-white{background:#fff;border:1px solid rgba(0,0,0,0.06)}
    /* turn timer glow */
    .turn-glow{animation:glowPulse 1s infinite}
    @keyframes glowPulse{0%{box-shadow:0 0 0 rgba(192,138,63,0)}50%{box-shadow:0 0 20px rgba(192,138,63,0.4)}100%{box-shadow:0 0 0 rgba(192,138,63,0)}}
    /* centered countdown overlay */
    #countdownOverlay{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%) scale(1);
      font-size:120px;
      font-weight:900;
      color:#333;
      opacity:0.15;
      text-shadow:0 0 20px rgba(0,0,0,0.3);
      pointer-events:none;
      transition:all 0.22s ease;
      z-index:40;
    }
    #countdownOverlay.flash {
      animation: flashGlow 0.5s infinite alternate;
    }
    @keyframes flashGlow {
      from { opacity: 0.3; text-shadow:0 0 12px rgba(255,60,60,0.4);}
      to   { opacity: 0.9; text-shadow:0 0 48px rgba(255,0,0,0.9);}
    }
    @media (max-width:720px){
      .board-wrap{width:90vw;height:90vw}
      #countdownOverlay{font-size:64px}
      .kcard{flex-direction:column;align-items:center}.k-avatar{width:96px;height:96px}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <div class="brand">
        <div class="logo">æŸ´</div>
        <div>
          <div style="font-weight:900">ç¬¨ç‹—å°æŸ´ äº”å­æ£‹</div>
          <div style="color:var(--muted);font-size:0.9rem">v10.3 Â· å€’è®¡æ—¶å±…ä¸­æ˜¾ç¤º</div>
        </div>
      </div>

      <div class="nav">
        <div id="connectionStatus" style="display:flex;align-items:center;margin-right:12px">
          <span id="connDot" class="status-dot" style="background:var(--offline)"></span>
          <span id="connText" style="color:var(--muted)">è¿æ¥ä¸­...</span>
        </div>
        <div style="width:12px"></div>
        <button id="btnGotoLobby" class="pill ghost">å¤§å…</button>
        <button id="btnGotoGame" class="pill ghost">å¯¹å¼ˆ</button>
      </div>
    </div>

    <div class="scenes">
      <!-- LOBBY -->
      <div id="lobbyScene" class="scene visible">
        <div class="card" style="width:100%;max-width:1000px">
          <div style="display:flex;gap:12px">
            <div style="flex:1">
              <div style="display:flex;gap:8px;align-items:center">
                <input id="roomInput" placeholder="æˆ¿é—´å·ï¼ˆå¯ç•™ç©ºéšæœºï¼‰" style="flex:1;padding:10px;border-radius:10px;border:1px solid rgba(0,0,0,0.06)" />
                <button id="createRoomBtn" class="pill primary">åˆ›å»º</button>
                <button id="refreshRoomsBtn" class="pill ghost">åˆ·æ–°</button>
              </div>
              <div id="roomsList" style="margin-top:14px;max-height:60vh;overflow:auto"></div>
            </div>
            <div style="width:320px;display:flex;flex-direction:column;gap:8px">
              <div style="font-weight:900">æ˜µç§°</div>
              <div style="display:flex;gap:8px">
                <input id="nickInput" placeholder="ä¾‹å¦‚ï¼šé˜¿ä¸€" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
                <button id="saveNickBtn" class="pill primary">ä¿å­˜</button>
              </div>
              <div style="color:var(--muted)">å½“å‰æ˜µç§°: <span id="myNick">-</span></div>
              <div style="margin-top:12px;color:var(--muted)">è¯´æ˜ï¼šèƒœåˆ©åä¼šå¼¹å‡ºçŸ¥è¯†å¡ç‰‡ï¼ˆæˆ¿é—´çº§ç‰Œå †ï¼Œå‡ºå®Œé‡ç½®ï¼‰ã€‚</div>
            </div>
          </div>
        </div>
      </div>

      <!-- GAME -->
      <div id="gameScene" class="scene">
        <div class="card" style="width:100%;max-width:1100px;display:flex;gap:12px;padding:12px">
          <div style="width:260px;display:flex;flex-direction:column;gap:12px">
            <div style="font-weight:900">ç©å®¶ä¿¡æ¯</div>
            <div class="player-row"><div class="piece-badge badge-black" aria-hidden="true"></div><strong id="blackName">é»‘æ–¹ï¼ˆç©ºï¼‰</strong><div class="chat-meta" id="blackId"></div></div>
            <div class="player-row"><div class="piece-badge badge-white" aria-hidden="true"></div><strong id="whiteName">ç™½æ–¹ï¼ˆç©ºï¼‰</strong><div class="chat-meta" id="whiteId"></div></div>

            <div style="margin-top:8px">
              <div style="font-weight:900">æ§åˆ¶</div>
              <div style="display:flex;gap:8px;margin-top:8px">
                <button id="restartBtn" class="pill ghost">é‡å¼€</button>
                <button id="requestUndoBtn" class="pill ghost">ç”³è¯·æ‚”æ£‹</button>
                <button id="leaveBtn" class="pill ghost">é€€å‡º</button>
              </div>
              <div style="margin-top:8px;color:var(--muted)">æˆ¿é—´: <span id="roomIdLabel">-</span></div>
              <div style="margin-top:6px;color:var(--muted)">æˆ¿ä¸»: <span id="ownerLabel">-</span></div>
            </div>
          </div>

          <div style="flex:1;display:flex;flex-direction:column;gap:8px;align-items:center">
            <div style="width:100%;display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:900">å¯¹å¼ˆåŒº</div>
              <div style="display:flex;align-items:center;gap:12px">
                <div id="turnLabel" style="font-weight:800;color:var(--muted);display:flex;align-items:center;gap:8px">- <span id="turnTimer" style="font-weight:900"></span></div>
                <div id="moveCount" class="chat-meta">æ­¥: 0</div>
              </div>
            </div>

            <!-- board wrap includes centered countdown overlay -->
            <div class="board-wrap">
              <div class="board" id="board"></div>
              <div id="countdownOverlay">30</div>
            </div>
          </div>

          <div style="width:320px;display:flex;flex-direction:column;gap:8px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:900">èŠå¤©</div>
              <div class="chat-meta" id="statusLabel">æœªåœ¨æˆ¿é—´</div>
            </div>
            <div id="chatLog" class="chat-log"></div>
            <div style="display:flex;gap:8px">
              <input id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯â€¦" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
              <button id="sendChatBtn" class="pill primary">å‘é€</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- confetti canvas -->
  <canvas id="confettiCanvas" class="confetti-canvas"></canvas>

  <!-- victory modal (simple) -->
  <div id="victoryModal">
    <div class="modal card" style="text-align:center;padding:18px;position:relative;">
      <h2 style="margin:0 0 8px 0">ğŸ‰ è·èƒœï¼</h2>
      <div id="victoryMessage" style="font-weight:900;margin-bottom:12px"></div>
      <div style="display:flex;gap:10px;justify-content:center">
        <button id="showKnowledgeBtn" class="pill primary">æŸ¥çœ‹çŸ¥è¯†å¡ç‰‡</button>
        <button id="closeVictoryBtn" class="pill ghost">å…³é—­</button>
      </div>
    </div>
  </div>

  <!-- knowledge modal -->
  <div id="knowledgeModal">
    <div class="kcard">
      <div class="k-avatar" id="kAvatar" aria-hidden="true">AI</div>
      <div class="k-body">
        <div class="k-name" id="kName">åå­—</div>
        <div class="k-meta" id="kMeta">èŒç§° Â· å¹´ä»½</div>
        <div class="k-desc" id="kDesc" style="margin-top:8px;color:#333">ç®€ä»‹</div>
        <div class="k-quote" id="kQuote">â€œåè¨€â€</div>
        <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
          <button id="shareKBtn" class="pill primary">å¤åˆ¶å¡ç‰‡æ–‡æœ¬</button>
          <button id="closeKBtn" class="pill ghost">å…³é—­</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ---------- Firebase imports ----------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-analytics.js";
    import {
      getDatabase, ref, push, set, onValue, onChildAdded, onChildRemoved, remove, get, update
    } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-database.js";

    // ---------- Firebase config (ä½ çš„é…ç½®) ----------
    const firebaseConfig = {
      apiKey: "AIzaSyCLeUHDLnxpd05HnioDdtOPKa5kMW4LQCE",
      authDomain: "wuyifan-code04.firebaseapp.com",
      projectId: "wuyifan-code04",
      storageBucket: "wuyifan-code04.firebasestorage.app",
      messagingSenderId: "1048037918553",
      appId: "1:1048037918553:web:8ed5388ba1ed7fb677ae48",
      measurementId: "G-3RTKTGRSJW",
      databaseURL: "https://wuyifan-code04-default-rtdb.asia-southeast1.firebasedatabase.app/"
    };

    const app = initializeApp(firebaseConfig);
    try { getAnalytics(app); } catch(e) { /* ignore */ }
    const db = getDatabase(app);

    // ---------- DOM refs ----------
    const connDot = document.getElementById('connDot');
    const connText = document.getElementById('connText');
    const roomsList = document.getElementById('roomsList');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const refreshRoomsBtn = document.getElementById('refreshRoomsBtn');
    const roomInput = document.getElementById('roomInput');
    const nickInput = document.getElementById('nickInput');
    const saveNickBtn = document.getElementById('saveNickBtn');
    const myNickLabel = document.getElementById('myNick');
    const boardEl = document.getElementById('board');
    const blackName = document.getElementById('blackName');
    const whiteName = document.getElementById('whiteName');
    const blackId = document.getElementById('blackId');
    const whiteId = document.getElementById('whiteId');
    const ownerLabel = document.getElementById('ownerLabel');
    const roomIdLabel = document.getElementById('roomIdLabel');
    const statusLabel = document.getElementById('statusLabel');
    const turnLabel = document.getElementById('turnLabel');
    const turnTimerEl = document.getElementById('turnTimer');
    const moveCountLabel = document.getElementById('moveCount');
    const requestUndoBtn = document.getElementById('requestUndoBtn');
    const restartBtn = document.getElementById('restartBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const chatLog = document.getElementById('chatLog');
    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const victoryModal = document.getElementById('victoryModal');
    const victoryMessage = document.getElementById('victoryMessage');
    const showKnowledgeBtn = document.getElementById('showKnowledgeBtn');
    const closeVictoryBtn = document.getElementById('closeVictoryBtn');
    const knowledgeModal = document.getElementById('knowledgeModal');
    const kAvatar = document.getElementById('kAvatar');
    const kName = document.getElementById('kName');
    const kMeta = document.getElementById('kMeta');
    const kDesc = document.getElementById('kDesc');
    const kQuote = document.getElementById('kQuote');
    const shareKBtn = document.getElementById('shareKBtn');
    const closeKBtn = document.getElementById('closeKBtn');
    const confettiCanvas = document.getElementById('confettiCanvas');
    const countdownOverlay = document.getElementById('countdownOverlay');

    // ---------- State ----------
    const boardSize = 15;
    let myClientId = 'u_' + Math.random().toString(36).slice(2,9);
    let myNick = localStorage.getItem('g_nick') || null;
    let myRoomId = null;
    let mySlot = null;
    let board = [];
    let moveHistory = []; // {row,col,player,key}
    let appliedMoveKeys = new Set();
    let connected = false;
    let lastKnownState = { currentPlayer: 'black', gameOver:false, winner:null, lastMoveKey:null, turnExpiresAt: null };
    let lastRoomMeta = {};
    let unsubRooms=null, unsubPlayers=null, unsubMovesAdded=null, unsubMovesRemoved=null, unsubChatsAdded=null, unsubState=null, unsubUndoRequests=null, unsubConnected=null;

    // ---------- Knowledge cards (sample) ----------
    const knowledgeCards = [
      { id: 'feifei', name: 'æé£é£ (Fei-Fei Li)', meta: 'æ–¯å¦ç¦å¤§å­¦ / è®¡ç®—æœºè§†è§‰ é¢†å¯¼è€…', desc: 'ImageNet æ˜¯æ¨åŠ¨ç°ä»£è®¡ç®—æœºè§†è§‰å‘å±•çš„å…³é”®èµ„æºã€‚æé£é£åœ¨æ„å»ºå¤§å‹è§†è§‰æ•°æ®é›†ä¸æ¨åŠ¨è§†è§‰ AI ç ”ç©¶ä¸Šå½±å“æ·±è¿œã€‚', quote: 'å½“æˆ‘ä»¬æŠŠæœºå™¨æ•™ä¼šçœ‹ä¸–ç•Œï¼Œæˆ‘ä»¬ä¹Ÿåœ¨é‡æ–°ç†è§£äººç±»å¦‚ä½•çœ‹ä¸–ç•Œã€‚' },
      { id: 'hinton', name: 'Geoffrey Hinton', meta: 'æ·±åº¦å­¦ä¹ å¥ åŸºäººä¸åå‘ä¼ æ’­æ¨å¹¿è€…', desc: 'Hinton åœ¨ç¥ç»ç½‘ç»œä¸æ·±åº¦å­¦ä¹ æ–¹é¢çš„æ—©æœŸè´¡çŒ®å¥ å®šäº†ç°ä»£ AI çš„åŸºç¡€ã€‚ä»–åœ¨åå‘ä¼ æ’­å’Œæ·±åº¦ç½‘ç»œæ–¹é¢çš„å·¥ä½œå‚¬ç”Ÿäº†ä»Šå¤©ä¼—å¤šæ¨¡å‹ã€‚', quote: 'èŠ‚çœç‰¹å¾å·¥ç¨‹ï¼Œè®©ç¥ç»ç½‘ç»œè‡ªå·±å»å­¦ä¹ ã€‚' },
      { id: 'bengio', name: 'Yoshua Bengio', meta: 'è’™ç‰¹åˆ©å°”å¤§å­¦ / æ·±åº¦å­¦ä¹ ç ”ç©¶å‘˜', desc: 'Bengio åœ¨æ¦‚ç‡æ¨¡å‹ã€ç”Ÿæˆæ¨¡å‹åŠç¥ç»ç½‘ç»œä¼˜åŒ–æ–¹é¢åšå‡ºå¤§é‡è´¡çŒ®ï¼Œæ˜¯æ·±åº¦å­¦ä¹ ç¤¾åŒºçš„é‡è¦äººç‰©ä¹‹ä¸€ã€‚', quote: 'å­¦ä¹ å¦‚ä½•å­¦ä¹ æ˜¯ AI é•¿è¿œå‘å±•çš„å…³é”®ã€‚' },
      { id: 'demis', name: 'Demis Hassabis', meta: 'DeepMind è”åˆåˆ›å§‹äºº', desc: 'å°†å¼ºåŒ–å­¦ä¹ ä¸å¤§è§„æ¨¡è®¡ç®—ç»“åˆå¹¶åº”ç”¨äºå¤æ‚å¯¹å¼ˆï¼ˆå¦‚ AlphaGoï¼‰ä¸ç§‘å­¦å‘ç°ä»»åŠ¡ï¼Œæ¨åŠ¨äº†æ™ºèƒ½ç³»ç»Ÿçš„æ–°æ–¹å‘ã€‚', quote: 'æŠŠæ¸¸æˆè§£å†³æ‰ï¼Œç„¶åæŠŠé‚£äº›å­¦ä¹ å¸¦åˆ°ç°å®ä¸–ç•Œã€‚' }
    ];
    const cardMap = Object.fromEntries(knowledgeCards.map(c=>[c.id,c]));

    // ---------- Helpers ----------
    function dbRef(path){ return ref(db, path); }
    function generateRoomId(){ return Math.random().toString(36).slice(2,8).toUpperCase(); }
    function updateNickUI(){ myNickLabel.textContent = myNick || '-'; }
    function resetLocalBoard(){ board = Array.from({length:boardSize}, ()=> Array(boardSize).fill(null)); moveHistory=[]; appliedMoveKeys=new Set(); boardEl.querySelectorAll('.cell').forEach(c=>{ c.innerHTML=''; c.classList.remove('winning-piece'); }); updateUIStats(); }
    function updateUIStats(){ turnLabel.textContent = (myRoomId && lastKnownState.currentPlayer) ? (lastKnownState.currentPlayer==='black' ? 'é»‘æ–¹å›åˆ' : 'ç™½æ–¹å›åˆ') : '-'; moveCountLabel.textContent = 'æ­¥: ' + moveHistory.length; statusLabel.textContent = (myRoomId && lastKnownState.gameOver) ? 'å¯¹å±€ç»“æŸ' : (myRoomId ? 'å¯¹å¼ˆä¸­' : 'æœªåœ¨æˆ¿é—´'); roomIdLabel.textContent = myRoomId || '-'; ownerLabel.textContent = lastRoomMeta.ownerNick || lastRoomMeta.ownerId || '-'; }

    // ---------- Board DOM ----------
    function initBoardDOM(){
      boardEl.innerHTML = '';
      for(let r=0;r<boardSize;r++){
        for(let c=0;c<boardSize;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r; cell.dataset.col = c;
          cell.addEventListener('click', handleCellClick);
          boardEl.appendChild(cell);
        }
      }
    }

    function placePieceLocal(r,c,player){
      if (board[r][c] !== null) return false;
      board[r][c] = player;
      const idx = r*boardSize + c;
      const cell = boardEl.children[idx];
      if (!cell) return false;
      const piece = document.createElement('div');
      piece.className = 'piece ' + player;
      requestAnimationFrame(()=> {
        cell.appendChild(piece);
        setTimeout(()=> piece.classList.add('drop'), 10);
      });
      return true;
    }

    function removePieceLocal(r,c){
      if (board[r][c] === null) return false;
      board[r][c] = null;
      const idx = r*boardSize + c;
      const cell = boardEl.children[idx];
      if (!cell) return false;
      cell.innerHTML = '';
      return true;
    }

    function markWinningPieces(coords){
      coords.forEach(({r,c})=>{
        const idx = r*boardSize + c;
        const cell = boardEl.children[idx];
        const p = cell && cell.querySelector('.piece');
        if (p) p.classList.add('winning-piece');
      });
    }

    function checkWinAndReturnCoords(r,c,player){
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dx,dy] of dirs){
        let coords = [{r,c}];
        for (let i=1;i<=4;i++){ const nr=r+i*dx, nc=c+i*dy; if(nr>=0&&nr<boardSize&&nc>=0&&nc<boardSize&&board[nr][nc]===player) coords.push({r:nr,c:nc}); else break; }
        for (let i=1;i<=4;i++){ const nr=r-i*dx, nc=c-i*dy; if(nr>=0&&nr<boardSize&&nc>=0&&nc<boardSize&&board[nr][nc]===player) coords.unshift({r:nr,c:nc}); else break; }
        if (coords.length>=5) return coords;
      }
      return null;
    }

    // ---------- Connection monitor ----------
    function startConnectionMonitor(){
      try{ if (unsubConnected) unsubConnected(); }catch(e){}
      const connRef = dbRef('.info/connected');
      unsubConnected = onValue(connRef, (snap)=>{
        const val = snap.val();
        connected = !!val;
        if (connected){
          connDot.style.background = 'var(--online)';
          connText.textContent = 'ğŸŸ¢ å·²è¿æ¥';
          if (myRoomId){
            setTimeout(()=> applyInitialRoomState(myRoomId).catch(()=>{}), 300);
            appendSystemChat('âœ… å·²é‡æ–°è¿æ¥å¹¶åŒæ­¥å¯¹å±€');
          }
        } else {
          connDot.style.background = 'var(--offline)';
          connText.textContent = 'ğŸ”´ ç¦»çº¿ï¼Œè‡ªåŠ¨é‡è¿ä¸­â€¦';
          appendSystemChat('âš ï¸ æ£€æµ‹åˆ°æ–­çº¿ï¼Œæš‚æ—¶ç¦æ­¢è½å­');
        }
      });
    }

    // ---------- Rooms list ----------
    function startRoomsListener(){
      try{ if (unsubRooms) unsubRooms(); }catch(e){}
      unsubRooms = onValue(dbRef('rooms'), snap=>{
        const data = snap.val() || {};
        renderRoomsList(data);
      });
    }
    function renderRoomsList(dataObj){
      roomsList.innerHTML = '';
      const arr = Object.entries(dataObj || {}).map(([k,v])=>({ id:k, ...v }));
      arr.sort((a,b)=> (b.createdAt||0)-(a.createdAt||0));
      if (arr.length===0){ roomsList.innerHTML = '<div style="color:var(--muted)">æš‚æ— æˆ¿é—´ï¼Œåˆ›å»ºä¸€ä¸ªå§</div>'; return; }
      arr.forEach(room=>{
        const players = room.players || {};
        const count = Object.keys(players).length;
        const item = document.createElement('div'); item.style.display='flex'; item.style.justifyContent='space-between'; item.style.alignItems='center'; item.style.marginBottom='8px';
        const meta = document.createElement('div'); meta.style.display='flex'; meta.style.flexDirection='column';
        const title = document.createElement('div'); title.style.fontWeight='800'; title.textContent = `æˆ¿é—´ ${room.id}`;
        const sub = document.createElement('div'); sub.className='chat-meta'; sub.textContent = `ç©å®¶: ${count}/2 Â· åˆ›å»º: ${room.createdAt ? new Date(room.createdAt).toLocaleString() : 'æœªçŸ¥'}`;
        meta.appendChild(title); meta.appendChild(sub);
        const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px';
        const enter = document.createElement('button'); enter.className='pill primary'; enter.textContent = count>=2 ? 'å·²æ»¡' : 'è¿›å…¥'; enter.disabled = count>=2;
        enter.onclick = ()=> joinRoom(room.id);
        const del = document.createElement('button'); del.className='pill ghost'; del.textContent='åˆ é™¤';
        del.onclick = async ()=> { if(!confirm(`åˆ é™¤æˆ¿é—´ ${room.id} ?`)) return; await remove(dbRef(`rooms/${room.id}`)); };
        actions.appendChild(enter); actions.appendChild(del); item.appendChild(meta); item.appendChild(actions);
        roomsList.appendChild(item);
      });
    }

    // ---------- Per-room listeners ----------
    function stopRoomListeners(){
      try{ if (unsubPlayers) unsubPlayers(); }catch(e){}
      try{ if (unsubState) unsubState(); }catch(e){}
      try{ if (unsubMovesAdded) unsubMovesAdded(); }catch(e){}
      try{ if (unsubMovesRemoved) unsubMovesRemoved(); }catch(e){}
      try{ if (unsubChatsAdded) unsubChatsAdded(); }catch(e){}
      try{ if (unsubUndoRequests) unsubUndoRequests(); }catch(e){}
      unsubPlayers = unsubState = unsubMovesAdded = unsubMovesRemoved = unsubChatsAdded = unsubUndoRequests = null;
      appliedMoveKeys = new Set();
      moveHistory = [];
      stopLocalTurnTimer();
    }

    function startRoomListeners(id){
      // players
      const playersRef = dbRef(`rooms/${id}/players`);
      try{ if (unsubPlayers) unsubPlayers(); }catch(e){}
      unsubPlayers = onValue(playersRef, snap=>{
        const players = snap.val() || {};
        updatePlayersUI(players);
      });

      // state
      const stateRef = dbRef(`rooms/${id}/state`);
      try{ if (unsubState) unsubState(); }catch(e){}
      unsubState = onValue(stateRef, snap=>{
        const s = snap.val() || {};
        lastKnownState = Object.assign({}, lastKnownState, s);
        if (s.gameOver){
          showVictoryFromState(s.winner);
        } else {
          hideVictory();
        }
        updateUIStats();
        // if turnExpiresAt present, start countdown
        if (lastKnownState.turnExpiresAt) startLocalTurnTimer(lastKnownState.turnExpiresAt, lastKnownState.currentPlayer);
      });

      // moves added
      const movesRef = dbRef(`rooms/${id}/moves`);
      try{ if (unsubMovesAdded) unsubMovesAdded(); }catch(e){}
      unsubMovesAdded = onChildAdded(movesRef, snap=>{
        const k = snap.key; const m = snap.val();
        if (!m) return;
        if (appliedMoveKeys.has(k)) return;
        appliedMoveKeys.add(k);
        applyRemoteMove(m,k);
      });

      // moves removed
      try{ if (unsubMovesRemoved) unsubMovesRemoved(); }catch(e){}
      unsubMovesRemoved = onChildRemoved(movesRef, snap=>{
        const k = snap.key; const m = snap.val();
        if (!m) return;
        if (appliedMoveKeys.has(k)){
          appliedMoveKeys.delete(k);
          const idx = moveHistory.findIndex(x=>x.key===k);
          if (idx !== -1){
            const mv = moveHistory.splice(idx,1)[0];
            removePieceLocal(mv.row, mv.col);
          } else {
            removePieceLocal(m.row, m.col);
          }
          updateUIStats();
        }
      });

      // chats
      const chatsRef = dbRef(`rooms/${id}/chats`);
      try{ if (unsubChatsAdded) unsubChatsAdded(); }catch(e){}
      unsubChatsAdded = onChildAdded(chatsRef, snap=>{
        const m = snap.val();
        if (!m) return;
        const t = new Date(m.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        appendChatLine(`[${t}] ${m.nick}: ${m.text}`);
      });

      // undo requests
      const undoRef = dbRef(`rooms/${id}/requests/undo`);
      try{ if (unsubUndoRequests) unsubUndoRequests(); }catch(e){}
      unsubUndoRequests = onChildAdded(undoRef, async (snap)=>{
        const key = snap.key; const req = snap.val();
        if (!req) return;
        if (req.from === myClientId) return; // ignore own
        if (req.status && req.status !== 'pending') return;
        const who = req.nick || 'å¯¹æ–¹';
        const agree = confirm(`${who} è¯·æ±‚æ‚”æ£‹ï¼šæ˜¯å¦åŒæ„æ’¤é”€ä»–ä»¬çš„æœ€åä¸€æ­¥ï¼Ÿï¼ˆåŒæ„åå°†åˆ é™¤æœ€åä¸€æ­¥ï¼‰`);
        if (agree){
          const movesSnap = await get(dbRef(`rooms/${myRoomId}/moves`));
          const moves = movesSnap.val() || {};
          const keys = Object.keys(moves).sort();
          if (keys.length === 0){
            await set(dbRef(`rooms/${myRoomId}/requests/undo/${key}/status`), 'accepted');
            await push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: `${myNick||'ç©å®¶'} åŒæ„äº†æ‚”æ£‹ï¼Œä½†æ£‹æ­¥ä¸ºç©ºã€‚`, timestamp: Date.now() });
          } else {
            const lastKey = keys[keys.length-1];
            const lastMove = moves[lastKey];
            if (lastMove && lastMove.clientId === req.from){
              await remove(dbRef(`rooms/${myRoomId}/moves/${lastKey}`));
              await set(dbRef(`rooms/${myRoomId}/requests/undo/${key}/status`), 'accepted');
              await set(dbRef(`rooms/${myRoomId}/state/currentPlayer`), lastMove.player);
              // also set turnExpiresAt anew
              await set(dbRef(`rooms/${myRoomId}/state/turnExpiresAt`), Date.now() + 30000);
              await push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: `${myNick||'ç©å®¶'} åŒæ„å¹¶æ’¤é”€äº† ${req.nick||'å¯¹æ–¹'} çš„æœ€åä¸€æ­¥ã€‚`, timestamp: Date.now() });
            } else {
              await set(dbRef(`rooms/${myRoomId}/requests/undo/${key}/status`), 'rejected');
              await push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: `${myNick||'ç©å®¶'} æ‹’ç»æ‚”æ£‹ï¼ˆæœ€åä¸€æ­¥ä¸æ˜¯è¯·æ±‚è€…æ‰€ä¸‹ï¼‰ã€‚`, timestamp: Date.now() });
            }
          }
        } else {
          await set(dbRef(`rooms/${myRoomId}/requests/undo/${key}/status`), 'rejected');
          await push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: `${myNick||'ç©å®¶'} æ‹’ç»äº†æ‚”æ£‹è¯·æ±‚ã€‚`, timestamp: Date.now() });
        }
      });
    }

    function updatePlayersUI(playersObj){
      const list = Object.entries(playersObj || {}).map(([id,p])=>({ id, ...p }));
      let black = null, white = null;
      list.forEach(p=>{ if (p.slot==='black') black=p; if (p.slot==='white') white=p; });
      blackName.textContent = black ? (black.nick||black.clientId) : 'é»‘æ–¹ï¼ˆç©ºï¼‰';
      whiteName.textContent = white ? (white.nick||white.clientId) : 'ç™½æ–¹ï¼ˆç©ºï¼‰';
      blackId.textContent = black ? `ID: ${black.clientId}` : '';
      whiteId.textContent = white ? `ID: ${white.clientId}` : '';
      updateUIStats();
    }

    async function applyInitialRoomState(roomId){
      resetLocalBoard();
      const movesSnap = await get(dbRef(`rooms/${roomId}/moves`));
      const moves = movesSnap.val() || {};
      const keys = Object.keys(moves).sort();
      for (const k of keys){
        const m = moves[k];
        if(!m) continue;
        if(!appliedMoveKeys.has(k)){
          appliedMoveKeys.add(k);
          placePieceLocal(m.row, m.col, m.player);
          moveHistory.push({ row:m.row, col:m.col, player:m.player, key:k });
        }
      }
      const metaSnap = await get(dbRef(`rooms/${roomId}/meta`));
      lastRoomMeta = metaSnap.val() || {};
      const stateSnap = await get(dbRef(`rooms/${roomId}/state`));
      lastKnownState = Object.assign({}, lastKnownState, stateSnap.val() || {});
      updateUIStats();
      renderChatOnce(roomId);
    }

    async function renderChatOnce(roomId){
      chatLog.innerHTML = '';
      const chatsSnap = await get(dbRef(`rooms/${roomId}/chats`));
      const chats = chatsSnap.val() || {};
      const entries = Object.entries(chats || []).sort((a,b)=> (a[1].timestamp||0) - (b[1].timestamp||0));
      entries.forEach(([k,m])=>{
        const t = new Date(m.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        appendChatLine(`[${t}] ${m.nick}: ${m.text}`);
      });
    }

    function applyRemoteMove(m, key){
      placePieceLocal(m.row, m.col, m.player);
      moveHistory.push({ row:m.row, col:m.col, player:m.player, key });
      const coords = checkWinAndReturnCoords(m.row, m.col, m.player);
      if (coords){
        markWinningPieces(coords);
      }
      updateUIStats();
    }

    function appendChatLine(text){
      const d = document.createElement('div'); d.className='chat-row'; d.textContent = text; chatLog.appendChild(d);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function appendSystemChat(msg){
      if (!myRoomId) return;
      push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: msg, timestamp: Date.now() }).catch(()=>{});
    }

    // ---------- Turn timer (local) ----------
    let localTimerId = null;
    let localBeepCtx = null;
    function startLocalTurnTimer(turnExpiresAt, currentPlayer){
      stopLocalTurnTimer();
      const overlay = document.getElementById('countdownOverlay');
      const tick = ()=>{
        const now = Date.now();
        const remaining = Math.max(0, Math.ceil((turnExpiresAt - now)/1000));
        turnTimerEl.textContent = remaining > 0 ? `${remaining}s` : '0s';

        // æ›´æ–°ä¸­å¤®å€’è®¡æ—¶ overlay
        if (overlay) {
          overlay.textContent = remaining > 0 ? remaining : '';
          overlay.style.opacity = remaining > 0 ? 0.15 : 0;
          overlay.style.color = remaining <= 5 ? '#d83b3b' : '#333';
          overlay.style.textShadow = remaining <= 5 ? 
            '0 0 40px rgba(255,60,60,0.6)' : '0 0 20px rgba(0,0,0,0.3)';
          overlay.style.transform = remaining <= 5 
            ? 'translate(-50%,-50%) scale(1.28)' 
            : 'translate(-50%,-50%) scale(1)';
          if (remaining <= 5 && remaining > 0) overlay.classList.add('flash'); else overlay.classList.remove('flash');
        }

        // æœ€å5ç§’è§†è§‰ + å£°éŸ³æç¤º
        if (remaining <= 5 && remaining > 0){
          turnLabel.classList.add('turn-glow');
          playBeep(remaining);
        } else {
          turnLabel.classList.remove('turn-glow');
        }

        if (now >= turnExpiresAt){
          stopLocalTurnTimer();
          if (overlay) { overlay.style.opacity = 0; overlay.classList.remove('flash'); }
          turnTimerEl.textContent = '0s';
          handleTurnTimeout(currentPlayer).catch(()=>{});
          return;
        }
        localTimerId = setTimeout(tick, 250);
      };
      tick();
    }
    function stopLocalTurnTimer(){
      if (localTimerId) clearTimeout(localTimerId);
      localTimerId = null;
      turnLabel.classList.remove('turn-glow');
      if (countdownOverlay) { countdownOverlay.classList.remove('flash'); countdownOverlay.style.opacity = 0; }
    }
    function playBeep(whichSecond){
      try {
        if (!localBeepCtx) localBeepCtx = new (window.AudioContext || window.webkitAudioContext)();
        const ctx = localBeepCtx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = 600 + (whichSecond*40);
        o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0.001, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0.08, ctx.currentTime + 0.01);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18);
        o.stop(ctx.currentTime + 0.2);
      } catch(e){ /* ignore audio errors */ }
    }

    // Called when turn timer reaches zero - try to advance turn
    async function handleTurnTimeout(expiredPlayer){
      if (!myRoomId) return;
      try {
        const stateSnap = await get(dbRef(`rooms/${myRoomId}/state`));
        const s = stateSnap.val() || {};
        // If still same player and not gameOver, switch
        if (s.currentPlayer === expiredPlayer && !s.gameOver){
          const next = (expiredPlayer === 'black') ? 'white' : 'black';
          // set new currentPlayer and new turnExpiresAt (20s)
          await set(dbRef(`rooms/${myRoomId}/state`), { currentPlayer: next, gameOver: false, winner: null, lastMoveKey: s.lastMoveKey || null, turnExpiresAt: Date.now() + 30000 });
          await push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: `${expiredPlayer === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'} è¶…æ—¶æœªä¸‹ï¼Œå›åˆè‡ªåŠ¨è½¬ç»™ ${next === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'}ã€‚`, timestamp: Date.now() });
        }
      } catch(e){ console.warn('timeout advance err', e); }
    }

    // ---------- Interactions ----------
    createRoomBtn.addEventListener('click', async ()=>{
      if (!myNick) return alert('è¯·å…ˆè®¾ç½®æ˜µç§°');
      try { if (typeof unsubRooms === 'function') { unsubRooms(); unsubRooms = null; } } catch(e){}
      const id = (roomInput.value && roomInput.value.trim()) ? roomInput.value.trim().toUpperCase() : generateRoomId();
      const roomRef = dbRef(`rooms/${id}`);
      const snap = await get(roomRef);
      if (snap.exists()){
        alert('æˆ¿é—´å·²å­˜åœ¨ï¼Œè¯·æ¢ä¸ªæˆ¿é—´å·');
        try { if (!unsubRooms) startRoomsListener(); } catch(e){}
        return;
      }
      // create room: set meta, initial state including turnExpiresAt, and initialize deckRemaining shuffled
      const deck = shuffleArray(knowledgeCards.map(c=>c.id));
      await set(roomRef, { createdAt: Date.now(), id, createdBy: myClientId });
      await set(dbRef(`rooms/${id}/meta`), { ownerId: myClientId, ownerNick: myNick });
      await set(dbRef(`rooms/${id}/state`), { currentPlayer:'black', gameOver:false, winner:null, lastMoveKey:null, turnExpiresAt: Date.now() + 30000 });
      await set(dbRef(`rooms/${id}/players/${myClientId}`), { slot:'black', clientId: myClientId, nick: myNick, joinedAt: Date.now() });
      // write deckRemaining to DB (room-level)
      await set(dbRef(`rooms/${id}/deckRemaining`), deck);
      myRoomId = id; mySlot = 'black'; lastRoomMeta = { ownerId: myClientId, ownerNick: myNick };
      startRoomListeners(id);
      await applyInitialRoomState(id);
      enterGameScene();
    });

    refreshRoomsBtn.addEventListener('click', ()=> startRoomsListener());

    saveNickBtn.addEventListener('click', ()=> {
      const v = (nickInput.value||'').trim();
      if (!v) return alert('è¯·è¾“å…¥æ˜µç§°');
      myNick = v; localStorage.setItem('g_nick', myNick); updateNickUI();
    });

    sendChatBtn.addEventListener('click', async ()=>{
      const txt = (chatInput.value||'').trim();
      if (!txt) return;
      if (!myRoomId) return alert('æœªåœ¨æˆ¿é—´');
      try {
        await push(dbRef(`rooms/${myRoomId}/chats`), { nick: myNick||('ç©å®¶'+myClientId.slice(-4)), text: txt, timestamp: Date.now() });
        chatInput.value = '';
      } catch(e){ console.error('chat push err', e); alert('å‘é€å¤±è´¥'); }
    });

    async function handleCellClick(e){
      const r = parseInt(e.currentTarget.dataset.row), c = parseInt(e.currentTarget.dataset.col);
      if (!myRoomId) return alert('è¯·å…ˆåˆ›å»ºæˆ–è¿›å…¥æˆ¿é—´');
      if (!connected) return alert('å½“å‰ç¦»çº¿ï¼Œæ— æ³•è½å­');
      if (board[r][c] !== null) return;
      if (mySlot !== 'black' && mySlot !== 'white') return alert('ä½ æ˜¯è§‚æˆ˜è€…ï¼Œæ— æ³•è½å­');
      const stateSnap = await get(dbRef(`rooms/${myRoomId}/state`));
      const s = stateSnap.val() || {};
      const turn = s.currentPlayer || 'black';
      if (s.gameOver) return alert('å¯¹å±€å·²ç»“æŸ');
      if (turn !== mySlot) return alert('å½“å‰ä¸æ˜¯ä½ çš„å›åˆ');
      placePieceLocal(r,c,mySlot);
      try {
        const pushRef = await push(dbRef(`rooms/${myRoomId}/moves`), { row:r, col:c, player:mySlot, clientId: myClientId, nick: myNick, timestamp: Date.now() });
        const next = (mySlot === 'black') ? 'white' : 'black';
        // update state: currentPlayer, lastMoveKey, and turnExpiresAt (20s from now)
        await set(dbRef(`rooms/${myRoomId}/state`), { currentPlayer: next, gameOver:false, winner:null, lastMoveKey: pushRef.key, turnExpiresAt: Date.now() + 30000 });
        const coords = checkWinAndReturnCoords(r,c,mySlot);
        if (coords){
          // winner: set state.gameOver true and also trigger knowledge card flow by setting winner and leaving deck handling to fetchAndShowKnowledgeCard
          await set(dbRef(`rooms/${myRoomId}/state`), { currentPlayer: next, gameOver:true, winner: mySlot, lastMoveKey: pushRef.key, turnExpiresAt: null });
          await push(dbRef(`rooms/${myRoomId}/chats`), { nick: 'ç³»ç»Ÿ', text: `${myNick||'æŸç©å®¶'} è·èƒœï¼`, timestamp: Date.now() });
          // now manage card: pop from deckRemaining and set lastKnowledge
          await fetchAndAssignKnowledgeCard(myRoomId, mySlot);
        }
      } catch(e){
        console.error('push move err', e);
        alert('è½å­å¤±è´¥ï¼š' + (e.message || e));
      }
    }

    // ---------- Request undo ----------
    requestUndoBtn.addEventListener('click', async ()=>{
      if (!myRoomId) return alert('æœªåœ¨æˆ¿é—´');
      if (!connected) return alert('ç¦»çº¿çŠ¶æ€ä¸å¯ç”³è¯·æ‚”æ£‹');
      try {
        const reqRef = push(dbRef(`rooms/${myRoomId}/requests/undo`));
        await set(reqRef, { from: myClientId, nick: myNick, timestamp: Date.now(), status: 'pending' });
        await push(dbRef(`rooms/${myRoomId}/chats`), { nick:'ç³»ç»Ÿ', text: `${myNick||'ç©å®¶'} å‘èµ·äº†æ‚”æ£‹è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ–¹ç¡®è®¤ã€‚`, timestamp: Date.now() });
        alert('æ‚”æ£‹è¯·æ±‚å·²å‘é€ï¼Œç­‰å¾…å¯¹æ–¹ç¡®è®¤');
      } catch(e){ console.error('undo request err', e); alert('ç”³è¯·å¤±è´¥'); }
    });

    // ---------- Restart / Leave ----------
    restartBtn.addEventListener('click', async ()=>{
      if (!myRoomId) return alert('æœªåœ¨æˆ¿é—´');
      const metaSnap = await get(dbRef(`rooms/${myRoomId}/meta`));
      const meta = metaSnap.val() || {};
      if (meta.ownerId !== myClientId) return alert('åªæœ‰æˆ¿ä¸»å¯ä»¥é‡å¼€');
      if (!confirm('ç¡®è®¤é‡å¼€ï¼Ÿ')) return;
      try {
        await remove(dbRef(`rooms/${myRoomId}/moves`));
        await set(dbRef(`rooms/${myRoomId}/state`), { currentPlayer:'black', gameOver:false, winner:null, lastMoveKey:null, turnExpiresAt: Date.now() + 30000 });
        await remove(dbRef(`rooms/${myRoomId}/chats`));
        resetLocalBoard();
        appendSystemChat('æˆ¿ä¸»å·²é‡å¼€æ–°çš„å¯¹å±€');
      } catch(e){ console.error('restart err', e); alert('é‡å¼€å¤±è´¥'); }
    });

    leaveBtn.addEventListener('click', async ()=>{
      if (!myRoomId) return alert('ç¡®å®šè¦é€€å‡ºæˆ¿é—´å—ï¼Ÿ');
      if (!confirm('ç¡®å®šè¦é€€å‡ºæˆ¿é—´å—ï¼Ÿ')) return;
      try { await remove(dbRef(`rooms/${myRoomId}/players/${myClientId}`)); } catch(e){}
      stopRoomListeners();
      myRoomId = null; mySlot = null;
      resetLocalBoard();
      exitGameScene();
      startRoomsListener();
    });

    // ---------- Victory flow: show modal, confetti, sound, knowledge card ----------
    function showVictoryFromState(winner){
      if (!winner) return;
      victoryMessage.textContent = `${winner === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'} è·èƒœï¼`;
      victoryModal.style.display = 'block';
      playVictorySound();
      startConfetti();
      // Try to show knowledge modal if lastKnowledge exists in DB
      setTimeout(async ()=>{
        const lkSnap = await get(dbRef(`rooms/${myRoomId}/lastKnowledge`));
        if (lkSnap.exists()){
          const obj = lkSnap.val();
          showKnowledgeCardFromDB(obj);
        } else {
          // fallback: show local random
          showKnowledgeCard();
        }
      }, 900);
    }
    function hideVictory(){ victoryModal.style.display = 'none'; stopConfetti(); }

    closeVictoryBtn.addEventListener('click', ()=>{ hideVictory(); });

    // show knowledge modal picking random card (fallback only)
    function showKnowledgeCard(){
      const card = knowledgeCards[Math.floor(Math.random()*knowledgeCards.length)];
      if (!card) return;
      kAvatar.textContent = card.name.split(' ').map(s=>s[0]).slice(0,2).join('');
      kName.textContent = card.name;
      kMeta.textContent = card.meta;
      kDesc.textContent = card.desc;
      kQuote.textContent = `â€œ${card.quote}â€`;
      knowledgeModal.classList.add('show');
      knowledgeModal.style.display = 'block';
    }
    // show knowledge card using an object retrieved from room.lastKnowledge
    function showKnowledgeCardFromDB(obj){
      if (!obj || !obj.cardId) return showKnowledgeCard();
      const card = cardMap[obj.cardId];
      if (!card) return showKnowledgeCard();
      kAvatar.textContent = card.name.split(' ').map(s=>s[0]).slice(0,2).join('');
      kName.textContent = card.name + (obj.recipient ? ` ï¼ˆå±•ç¤ºï¼š${obj.recipient === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'}ï¼‰` : '');
      kMeta.textContent = card.meta;
      kDesc.textContent = card.desc;
      kQuote.textContent = `â€œ${card.quote}â€`;
      knowledgeModal.classList.add('show');
      knowledgeModal.style.display = 'block';
    }
    closeKBtn.addEventListener('click', ()=>{ knowledgeModal.classList.remove('show'); setTimeout(()=> knowledgeModal.style.display='none',220); });
    shareKBtn.addEventListener('click', ()=>{
      const text = `${kName.textContent}\n${kMeta.textContent}\n\n${kDesc.textContent}\n\n${kQuote.textContent}`;
      navigator.clipboard?.writeText(text).then(()=> alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'), ()=> alert('å¤åˆ¶å¤±è´¥'));
    });
    showKnowledgeBtn.addEventListener('click', async ()=>{
      const lkSnap = await get(dbRef(`rooms/${myRoomId}/lastKnowledge`));
      if (lkSnap.exists()) showKnowledgeCardFromDB(lkSnap.val()); else showKnowledgeCard();
    });

    // ---------- Confetti (simple canvas) ----------
    const confettiCtx = confettiCanvas.getContext && confettiCanvas.getContext('2d');
    let confettiParticles = [], confettiRunning=false;
    function resizeConfetti(){ confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeConfetti);
    resizeConfetti();

    function startConfetti(){
      if (!confettiCtx) return;
      confettiParticles = [];
      const colors = ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#9B5DE5'];
      for (let i=0;i<80;i++){
        confettiParticles.push({
          x: Math.random()*confettiCanvas.width,
          y: Math.random()*-confettiCanvas.height,
          w: 6 + Math.random()*10,
          h: 8 + Math.random()*12,
          vx: -1 + Math.random()*2,
          vy: 2 + Math.random()*4,
          r: Math.random()*360,
          color: colors[Math.floor(Math.random()*colors.length)],
          spin: (Math.random()*6-3)
        });
      }
      if (!confettiRunning) { confettiRunning = true; requestAnimationFrame(confettiFrame); }
      setTimeout(()=> stopConfetti(), 6000);
    }
    function stopConfetti(){ confettiRunning = false; confettiCtx && confettiCtx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height); }
    function confettiFrame(){
      if (!confettiRunning){ if (confettiCtx) confettiCtx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height); return; }
      confettiCtx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
      confettiParticles.forEach(p=>{
        p.x += p.vx; p.y += p.vy; p.vy += 0.02; p.r += p.spin;
        confettiCtx.save();
        confettiCtx.translate(p.x,p.y);
        confettiCtx.rotate(p.r * Math.PI/180);
        confettiCtx.fillStyle = p.color;
        confettiCtx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        confettiCtx.restore();
      });
      confettiParticles = confettiParticles.filter(p=>p.y < confettiCanvas.height + 50);
      if (confettiParticles.length === 0) { confettiRunning=false; return; }
      requestAnimationFrame(confettiFrame);
    }

    // ---------- Victory sound ----------
    function playVictorySound(){
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(440, ctx.currentTime);
        o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0.15, ctx.currentTime + 0.01);
        o.start();
        o.frequency.exponentialRampToValueAtTime(660, ctx.currentTime + 0.18);
        setTimeout(()=> { g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.4); o.stop(ctx.currentTime + 0.5); }, 300);
      } catch(e){ console.warn('audio err', e); }
    }

    // ---------- Deck / knowledge management ----------
    // shuffle helper
    function shuffleArray(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // When a victory occurs, pop one card from rooms/{id}/deckRemaining and set rooms/{id}/lastKnowledge
    async function fetchAndAssignKnowledgeCard(roomId, winnerSlot){
      try {
        const deckSnap = await get(dbRef(`rooms/${roomId}/deckRemaining`));
        let deck = deckSnap.exists() ? (deckSnap.val() || []) : [];
        // if deck missing or empty, reinitialize as shuffled full deck
        if (!deck || deck.length === 0){
          deck = shuffleArray(knowledgeCards.map(c=>c.id));
        }
        const cardId = deck.shift(); // take first
        // randomly choose recipient side (åŒæ–¹éšæœºå‡ºç°)
        const recipient = Math.random() < 0.5 ? 'black' : 'white';
        // write back deckRemaining and lastKnowledge
        await set(dbRef(`rooms/${roomId}/deckRemaining`), deck);
        await set(dbRef(`rooms/${roomId}/lastKnowledge`), { cardId, recipient, assignedAt: Date.now(), assignedBy: myClientId, winner: winnerSlot });
        // if deck is now empty after pop, it will be reinitialized on next need
      } catch(e){ console.warn('assign knowledge err', e); }
    }

    // ---------- Join / create / leave / listeners bootstrap ----------
    function enterGameScene(){ document.getElementById('lobbyScene').classList.remove('visible'); document.getElementById('gameScene').classList.add('visible'); updateUIStats(); }
    function exitGameScene(){ document.getElementById('gameScene').classList.remove('visible'); document.getElementById('lobbyScene').classList.add('visible'); }

    async function joinRoom(requestedRoomId){
      if (!myNick) return alert('è¯·å…ˆè®¾ç½®æ˜µç§°');
      if (myRoomId) await leaveRoom();
      try { if (typeof unsubRooms === 'function') { unsubRooms(); unsubRooms = null; } } catch(e){}
      const id = (requestedRoomId && requestedRoomId.trim()) ? requestedRoomId.trim().toUpperCase() : generateRoomId();
      myRoomId = id;
      const roomRef = dbRef(`rooms/${id}`);
      const snap = await get(roomRef);
      if (!snap.exists()){
        // if room not exists create with deck
        await set(roomRef, { createdAt: Date.now(), id, createdBy: myClientId });
        await set(dbRef(`rooms/${id}/meta`), { ownerId: myClientId, ownerNick: myNick });
        await set(dbRef(`rooms/${id}/state`), { currentPlayer:'black', gameOver:false, winner:null, lastMoveKey:null, turnExpiresAt: Date.now() + 30000 });
        await set(dbRef(`rooms/${id}/deckRemaining`), shuffleArray(knowledgeCards.map(c=>c.id)));
      } else {
        const metaSnap = await get(dbRef(`rooms/${id}/meta`));
        if (!metaSnap.exists()){
          await set(dbRef(`rooms/${id}/meta`), { ownerId: myClientId, ownerNick: myNick });
        }
      }
      const playersSnap = await get(dbRef(`rooms/${id}/players`));
      const playersObj = playersSnap.val() || {};
      const slots = Object.values(playersObj || {}).map(p=>p.slot);
      let desired = 'spectator';
      if (!slots.includes('black')) desired = 'black';
      else if (!slots.includes('white')) desired = 'white';
      await set(dbRef(`rooms/${id}/players/${myClientId}`), { slot: desired, clientId: myClientId, nick: myNick, joinedAt: Date.now() });
      mySlot = desired;
      const metaSnap2 = await get(dbRef(`rooms/${id}/meta`));
      lastRoomMeta = metaSnap2.val() || {};
      startRoomListeners(id);
      await applyInitialRoomState(id);
      enterGameScene();
    }

    async function leaveRoom(){
      if (!myRoomId) return;
      try { await remove(dbRef(`rooms/${myRoomId}/players/${myClientId}`)); } catch(e){}
      stopRoomListeners();
      myRoomId = null; mySlot = null;
      resetLocalBoard();
      exitGameScene();
      startRoomsListener();
    }

    // ---------- Event bindings ----------
    document.getElementById('btnGotoLobby').addEventListener('click', ()=> exitGameScene());
    document.getElementById('btnGotoGame').addEventListener('click', ()=> { if (!myRoomId) return alert('è¯·å…ˆåˆ›å»ºæˆ–è¿›å…¥æˆ¿é—´'); enterGameScene(); });
    document.getElementById('showKnowledgeBtn').addEventListener('click', async ()=>{
      const lkSnap = await get(dbRef(`rooms/${myRoomId}/lastKnowledge`));
      if (lkSnap.exists()) showKnowledgeCardFromDB(lkSnap.val()); else showKnowledgeCard();
    });

    // ---------- Bootstrapping ----------
    (async function bootstrap(){
      initBoardDOM();
      resetLocalBoard();
      myNick = myNick || ('ç©å®¶_' + myClientId.slice(-4));
      updateNickUI();
      startConnectionMonitor();
      try { await get(dbRef('/')); } catch(e){ console.error(e); }
      startRoomsListener();
      window.addEventListener('beforeunload', async ()=>{ try { if (myRoomId && myClientId) await remove(dbRef(`rooms/${myRoomId}/players/${myClientId}`)); } catch(e){} });
    })();

    // ---------- Unload cleanup ----------
    window.addEventListener('beforeunload', async ()=>{ try { if (myRoomId && myClientId) await remove(dbRef(`rooms/${myRoomId}/players/${myClientId}`)); } catch(e){} });

  </script>
</body>
</html>


